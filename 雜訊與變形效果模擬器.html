<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Processing Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }

        input[type="text"] {
            width: 30px;
        }

        #outputCanvas {
            border: 1px solid black;
            margin-top: 20px;
        }

        #controls {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>雜訊與變形效果模擬器</h1>
    <div id="controls">
        <input type="file" id="fileInput" accept="image/*">
        <br><br>
        <label>Angle: <input type="text" id="angleInput" value="0"></label>
        <button onclick="rotateImage()">Rotate</button>
        <button onclick="twirlImage()">Twirl</button>
        <br><br>
        <label>Scale: <input type="text" id="scaleInput" value="60"></label>
        <label>P: <input type="text" id="pInput" value="0.3"></label>
        <br><br>
        <button onclick="addNoise('uniform')">均勻雜訊</button>
        <button onclick="addNoise('gaussian')">高斯雜訊</button>
        <button onclick="addNoise('exponential')">指數雜訊</button>
        <button onclick="addNoise('impulse')">脈衝雜訊</button>
        <br><br>
    </div>
    <canvas id="outputCanvas" width="500" height="500"></canvas>

    <script>
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d');
        let image = new Image();
        let originalImageData = null;

        // Load and draw the image
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    image.src = event.target.result;
                    image.onload = () => {
                        canvas.width = image.width;
                        canvas.height = image.height;
                        ctx.drawImage(image, 0, 0);
                        // Save the original image data
                        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // Rotate the image
        function rotateImage() {
            const angle = parseFloat(document.getElementById('angleInput').value) || 0;
            const radians = (Math.PI / 180) * angle;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            tempCtx.translate(canvas.width / 2, canvas.height / 2);
            tempCtx.rotate(radians);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
        }

        // Twirl Effect
        function twirlImage() {
            if (!originalImageData) return;

            const twirlRadius = canvas.width / 2; // Radius of the twirl
            const angleFactor = Math.PI / 180;   // Twirl strength (changeable)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Create a new canvas to store the twirled image
            const newImageData = ctx.createImageData(canvas.width, canvas.height);
            const newData = newImageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const offsetX = x - centerX;
                    const offsetY = y - centerY;
                    const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);

                    // Only twirl pixels within the twirl radius
                    if (distance < twirlRadius) {
                        const angle = angleFactor * (1 - distance / twirlRadius) * 180;
                        const newAngle = Math.atan2(offsetY, offsetX) + angle;

                        const srcX = Math.floor(centerX + distance * Math.cos(newAngle));
                        const srcY = Math.floor(centerY + distance * Math.sin(newAngle));

                        if (srcX >= 0 && srcX < canvas.width && srcY >= 0 && srcY < canvas.height) {
                            const srcIndex = (srcY * canvas.width + srcX) * 4;
                            const destIndex = (y * canvas.width + x) * 4;

                            newData[destIndex] = data[srcIndex];       // R
                            newData[destIndex + 1] = data[srcIndex + 1]; // G
                            newData[destIndex + 2] = data[srcIndex + 2]; // B
                            newData[destIndex + 3] = data[srcIndex + 3]; // A
                        }
                    } else {
                        // Outside twirl radius, keep original pixel
                        const srcIndex = (y * canvas.width + x) * 4;
                        const destIndex = srcIndex;
                        newData[destIndex] = data[srcIndex];
                        newData[destIndex + 1] = data[srcIndex + 1];
                        newData[destIndex + 2] = data[srcIndex + 2];
                        newData[destIndex + 3] = data[srcIndex + 3];
                    }
                }
            }

            ctx.putImageData(newImageData, 0, 0);
        }

        // Add noise to the image
        function addNoise(type) {
            if (!originalImageData) return;

            // Reset to the original image
            ctx.putImageData(originalImageData, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const noise = generateNoise(type);
                data[i] = clamp(data[i] + noise);     // Red
                data[i + 1] = clamp(data[i + 1] + noise); // Green
                data[i + 2] = clamp(data[i + 2] + noise); // Blue
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Generate different types of noise
        function generateNoise(type) {
            switch (type) {
                case 'uniform':
                    return Math.random() * 255 - 128;
                case 'gaussian':
                    let u = 0, v = 0;
                    while (u === 0) u = Math.random();
                    while (v === 0) v = Math.random();
                    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * 64;
                case 'exponential':
                    return -Math.log(1 - Math.random()) * 64;
                case 'impulse':
                    return Math.random() < 0.5 ? -255 : 255;
                default:
                    return 0;
            }
        }

        // Clamp pixel values to [0, 255]
        function clamp(value) {
            return Math.max(0, Math.min(255, value));
        }
    </script>
</body>
</html>
